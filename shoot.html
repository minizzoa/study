<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BOSS RAID - Counter Attack</title>
    <style>
        body { margin: 0; background: #050507; color: white; font-family: 'Pretendard', sans-serif; display: flex; flex-direction: column; align-items: center; min-height: 100vh; overflow: hidden; }
        #game-header { margin-top: 15px; }
        #game-header h1 { font-size: 2rem; margin: 0; color: #ff3e3e; text-shadow: 0 0 15px #ff3e3e; }
        #game-container { position: relative; width: 95vw; max-width: 450px; height: 75vh; max-height: 650px; background: #000; border: 3px solid #444; border-radius: 15px; margin-top: 10px; overflow: hidden; }
        canvas { width: 100%; height: 100%; display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 15px; box-sizing: border-box; }
        .stats-row { display: flex; justify-content: space-between; font-size: 1.1rem; font-weight: bold; margin-bottom: 5px; }
        #damage-flash { position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(255,0,0,0); pointer-events: none; transition: background 0.1s; }
        .boss-warning { position: absolute; top: 35%; width: 100%; text-align: center; color: #ff0000; font-size: 2.2rem; font-weight: bold; display: none; animation: blink 0.5s infinite; }
        @keyframes blink { 0%, 100% { opacity: 0; } 50% { opacity: 1; } }
        #menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: auto; text-align: center; background: rgba(0,0,0,0.9); padding: 30px; border-radius: 20px; width: 85%; border: 2px solid #ff3e3e; }
        button { background: #ff3e3e; border: none; padding: 12px 25px; font-size: 1.1rem; font-weight: bold; color: white; border-radius: 50px; cursor: pointer; margin: 10px; }
        .bottom-controls { position: absolute; bottom: 15px; width: calc(100% - 30px); display: flex; justify-content: space-between; pointer-events: auto; }
        .ctrl-btn { background: rgba(255,255,255,0.1); font-size: 0.8rem; padding: 6px 15px; color: #aaa; border-radius: 5px; border: 1px solid #444; }
    </style>
</head>
<body>

    <div id="game-header"><h1>BOSS RAID</h1></div>

    <div id="game-container">
        <div id="damage-flash"></div>
        <canvas id="gameCanvas"></canvas>
        <div id="ui-layer">
            <div class="stats-row">
                <span>HI-SCORE: <span id="hiScore" style="color:#ff0">0</span></span>
                <span id="lifeDisplay" style="color:#f44; letter-spacing: 2px;">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
            </div>
            <div class="stats-row">
                <span>SCORE: <span id="score" style="color:#0cf">0</span></span>
                <span>TIME: <span id="time" style="color:#ff0">0</span>s</span>
            </div>
            
            <div id="bossWarning" class="boss-warning">WARNING: BOSS EVOLVING!</div>

            <div class="bottom-controls">
                <button class="ctrl-btn" id="soundBtn" onclick="toggleSound()">üîä Sound ON</button>
                <button class="ctrl-btn" onclick="togglePause()">|| ÏùºÏãúÏ†ïÏßÄ</button>
            </div>

            <div id="menu">
                <h2 id="menuTitle" style="color:#ff3e3e;">READY?</h2>
                <div id="scoreBoard" style="margin-bottom: 15px; line-height: 1.6;">
                    <p id="menuScoreText"></p>
                    <p id="bestScoreText" style="color:#ff0; font-weight: bold;"></p>
                </div>
                <button id="startBtn" onclick="startGame()">Ï†ÑÌà¨ ÏãúÏûë</button>
            </div>
        </div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const hiScoreDisplay = document.getElementById('hiScore');
const timeDisplay = document.getElementById('time');
const lifeDisplay = document.getElementById('lifeDisplay');
const menu = document.getElementById('menu');
const menuTitle = document.getElementById('menuTitle');
const bossWarning = document.getElementById('bossWarning');
const flash = document.getElementById('damage-flash');

canvas.width = 450;
canvas.height = 650;

const soldierImg = new Image(); soldierImg.src = 'soldier.png';
const badImg = new Image(); badImg.src = 'bad.png';
const bossImg = new Image(); bossImg.src = 'boss.png';

let player = { x: 225, y: 580, size: 25, weaponLv: 1, lives: 5, invul: 0 };
let bullets = [], enemyBullets = [], enemies = [], items = [], bosses = [];
let isPaused = true, isSoundOn = true;
let startTime = 0, elapsedTime = 0, frameCount = 0;
let score = 0, hiScore = localStorage.getItem('bossRaidHiScore') || 0;
let bossKillCount = 0;
let isBossSummoned = false;

const BOSS_TRIGGER_SCORE = 1000; 
hiScoreDisplay.innerText = hiScore;

const weaponData = {
    1: { damage: 1, color: '#fff', size: 4, speed: 10, fireRate: 15 },
    2: { damage: 2, color: '#0f0', size: 8, speed: 12, fireRate: 12 },
    3: { damage: 5, color: '#0cf', size: 16, speed: 15, fireRate: 8 },
    4: { damage: 20, color: '#f0f', size: 35, speed: 20, fireRate: 6 }
};

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(f, t, d, v) {
    if (!isSoundOn) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = t; o.frequency.setValueAtTime(f, audioCtx.currentTime);
    g.gain.setValueAtTime(v, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + d);
}

function toggleSound() {
    isSoundOn = !isSoundOn;
    document.getElementById('soundBtn').innerText = isSoundOn ? "üîä Sound ON" : "üîá Sound OFF";
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

const handleInput = (e) => {
    if (isPaused) return;
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const scaleX = canvas.width / rect.width;
    player.x = Math.max(player.size, Math.min(canvas.width - player.size, (clientX - rect.left) * scaleX));
};
window.addEventListener('mousemove', handleInput);
window.addEventListener('touchmove', (e) => { e.preventDefault(); handleInput(e); }, { passive: false });

function startGame() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    isPaused = false; menu.style.display = 'none';
    if(player.lives <= 0 || elapsedTime === 0) resetGame();
    requestAnimationFrame(loop);
}

function togglePause() {
    isPaused = !isPaused;
    menu.style.display = isPaused ? 'block' : 'none';
    if (isPaused) {
        menuTitle.innerText = "ÏùºÏãúÏ†ïÏßÄ";
        document.getElementById('bestScoreText').innerText = `ÏµúÍ≥† Í∏∞Î°ù: ${hiScore}`;
    } else requestAnimationFrame(loop);
}

function resetGame() {
    player = { x: 225, y: 580, size: 25, weaponLv: 1, lives: 5, invul: 0 };
    bullets = []; enemyBullets = []; enemies = []; items = []; bosses = [];
    score = 0; bossKillCount = 0; isBossSummoned = false;
    elapsedTime = 0; frameCount = 0; startTime = Date.now();
    updateUI();
}

function playerHit() {
    if (player.invul > 0) return;
    player.lives--;
    player.invul = 60; // ÏïΩ 1Ï¥à Î¨¥Ï†Å
    triggerFlash();
    playSound(100, 'sine', 0.5, 0.2);
    if (player.lives <= 0) gameOver();
}

function triggerFlash() {
    flash.style.background = "rgba(255, 0, 0, 0.4)";
    setTimeout(() => flash.style.background = "rgba(255, 0, 0, 0)", 100);
}

function updateUI() {
    scoreDisplay.innerText = score;
    timeDisplay.innerText = elapsedTime;
    lifeDisplay.innerText = "‚ù§Ô∏è".repeat(Math.max(0, player.lives));
    if (score > hiScore) {
        hiScore = score;
        hiScoreDisplay.innerText = hiScore;
        localStorage.setItem('bossRaidHiScore', hiScore);
    }
}

function update() {
    if (isPaused) return;
    frameCount++;
    if (player.invul > 0) player.invul--;
    elapsedTime = Math.floor((Date.now() - startTime) / 1000);
    updateUI();

    const isBossActive = bosses.length > 0;
    const spawnRate = isBossActive ? 50 : Math.max(5, 35 - Math.floor(elapsedTime / 8)); 
    
    if (frameCount % spawnRate === 0) {
        enemies.push({ 
            x: Math.random() * (canvas.width - 40) + 20, y: -40, 
            hp: 2 + Math.floor(elapsedTime / 15),
            size: 20 + Math.random() * 10, speed: 2 + (elapsedTime / 50),
            lastShot: frameCount
        });
    }

    // --- Î≥¥Ïä§ ÏÜåÌôò ---
    if (!isBossActive && score >= (bossKillCount + 1) * BOSS_TRIGGER_SCORE && !isBossSummoned) {
        isBossSummoned = true;
        bossWarning.style.display = 'block';
        playSound(60, 'square', 2.5, 0.25);
        setTimeout(() => {
            bossWarning.style.display = 'none';
            const evolveFactor = bossKillCount;
            bosses.push({
                x: canvas.width / 2, y: -150, 
                size: Math.min(150, 90 + evolveFactor * 10),
                hp: 500 + (evolveFactor * 400), maxHp: 500 + (evolveFactor * 400),
                speed: 0.7 + (evolveFactor * 0.2),
                lastShot: frameCount
            });
            isBossSummoned = false;
        }, 3000);
    }

    // ÌîåÎ†àÏù¥Ïñ¥ Î∞úÏÇ¨
    const wp = weaponData[player.weaponLv];
    if (frameCount % wp.fireRate === 0) {
        bullets.push({ x: player.x, y: player.y - 25, ...wp });
        playSound(700, 'sine', 0.08, 0.02);
    }

    // Ï†ÅÍµ∞ Î∞úÏÇ¨ Î°úÏßÅ
    enemies.forEach(e => {
        if (frameCount - e.lastShot > 100) { // ÏùºÎ∞ò Ï†ÅÏùÄ ÏïΩ 1.6Ï¥àÎßàÎã§ Î∞úÏÇ¨
            enemyBullets.push({ x: e.x, y: e.y + 10, speed: 4, size: 5, color: '#f00' });
            e.lastShot = frameCount;
        }
    });

    // Î≥¥Ïä§ Î∞úÏÇ¨ Î°úÏßÅ (ÌÉÑÎßâ Ïä§ÌÉÄÏùº)
    bosses.forEach(b => {
        if (frameCount % 60 === 0) { // 1Ï¥àÎßàÎã§ Ïó¨Îü¨ Í∞àÎûò Î∞úÏÇ¨
            for(let i=-2; i<=2; i++) {
                enemyBullets.push({ x: b.x + (i*20), y: b.y + b.size/2, speed: 5, size: 8, color: '#ff0', vx: i*1 });
            }
            playSound(150, 'square', 0.2, 0.05);
        }
    });

    // ÌîåÎ†àÏù¥Ïñ¥ Ï¥ùÏïå Ï≤òÎ¶¨
    bullets.forEach((b, bi) => {
        b.y -= b.speed;
        bosses.forEach((boss, bsi) => {
            if (Math.hypot(boss.x - b.x, boss.y - b.y) < boss.size) {
                boss.hp -= b.damage;
                bullets.splice(bi, 1);
                if (boss.hp <= 0) {
                    score += 5000 + (bossKillCount * 1000);
                    bossKillCount++;
                    playSound(30, 'sawtooth', 2, 0.4);
                    items.push({ x: boss.x, y: boss.y, lv: Math.min(4, player.weaponLv + 1) });
                    bosses.splice(bsi, 1);
                }
            }
        });
        enemies.forEach((e, ei) => {
            if (Math.hypot(e.x - b.x, e.y - b.y) < e.size) {
                e.hp -= b.damage;
                bullets.splice(bi, 1);
                if (e.hp <= 0) {
                    score += 100;
                    if (Math.random() > 0.9) items.push({ x: e.x, y: e.y, lv: player.weaponLv + 1 });
                    enemies.splice(ei, 1);
                }
            }
        });
    });

    // Ï†ÅÍµ∞ Ï¥ùÏïå Ï≤òÎ¶¨ (ÌîåÎ†àÏù¥Ïñ¥ ÌîºÍ≤©)
    enemyBullets.forEach((eb, ebi) => {
        eb.y += eb.speed;
        if (eb.vx) eb.x += eb.vx;
        if (Math.hypot(player.x - eb.x, player.y - eb.y) < player.size + eb.size) {
            enemyBullets.splice(ebi, 1);
            playerHit();
        }
    });

    bosses.forEach(b => {
        if (b.y < 150) b.y += 1.5;
        else b.x += Math.sin(frameCount / 40) * (b.speed * 5);
    });

    enemies.forEach((e, ei) => {
        e.y += e.speed;
        if (e.y > canvas.height + e.size) {
            enemies.splice(ei, 1);
            playerHit();
        }
    });

    items.forEach((item, ii) => {
        item.y += 2.5;
        if (Math.hypot(player.x - item.x, player.y - item.y) < 35) {
            player.weaponLv = Math.min(4, item.lv);
            items.splice(ii, 1);
        }
    });

    bullets = bullets.filter(b => b.y > -50);
    enemyBullets = enemyBullets.filter(eb => eb.y < canvas.height + 50);
}

function gameOver() {
    isPaused = true; 
    menu.style.display = 'block';
    menuTitle.innerText = "GAME OVER";
    document.getElementById('menuScoreText').innerText = `ÏµúÏ¢Ö Ï†êÏàò: ${score}`;
    document.getElementById('bestScoreText').innerText = `ÏµúÍ≥† Í∏∞Î°ù: ${hiScore}`;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Î≥¥Ïä§ Í∑∏Î¶¨Í∏∞
    bosses.forEach(b => {
        if (bossImg.complete) ctx.drawImage(bossImg, b.x - b.size, b.y - b.size, b.size * 2, b.size * 2);
        ctx.fillStyle = '#222'; ctx.fillRect(b.x - 80, b.y - b.size - 25, 160, 10);
        ctx.fillStyle = '#f00'; ctx.fillRect(b.x - 80, b.y - b.size - 25, (b.hp/b.maxHp) * 160, 10);
    });

    // ÌîåÎ†àÏù¥Ïñ¥ (Î¨¥Ï†Å ÏÉÅÌÉú Ïãú ÍπúÎπ°ÏûÑ)
    if (!(player.invul > 0 && frameCount % 4 < 2)) {
        if (soldierImg.complete) {
            const drawSize = player.size * 2.8; 
            ctx.drawImage(soldierImg, player.x - drawSize/2, player.y - drawSize/2, drawSize, drawSize);
        }
    }

    // Ï†ÅÍµ∞
    enemies.forEach(e => {
        if (badImg.complete) ctx.drawImage(badImg, e.x - e.size, e.y - e.size, e.size * 2, e.size * 2);
    });

    // Ï¥ùÏïå
    bullets.forEach(b => {
        ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2); ctx.fill();
    });

    // Ï†ÅÍµ∞ Ï¥ùÏïå (Î∂âÏùÄÏÉâ/ÎÖ∏ÎûÄÏÉâ Î†àÏù¥Ï†Ä)
    enemyBullets.forEach(eb => {
        ctx.fillStyle = eb.color;
        ctx.shadowBlur = 10; ctx.shadowColor = eb.color;
        ctx.beginPath(); ctx.arc(eb.x, eb.y, eb.size, 0, Math.PI * 2); ctx.fill();
    });
    ctx.shadowBlur = 0;

    items.forEach(item => {
        ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(item.x, item.y, 14, 0, Math.PI * 2); ctx.fill();
    });
}

function loop() {
    if (!isPaused) { update(); draw(); requestAnimationFrame(loop); }
}
</script>
</body>
</html>