<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BOSS RAID - Balanced Edition</title>
    <style>
        body { margin: 0; background: #050507; color: white; font-family: 'Pretendard', sans-serif; display: flex; flex-direction: column; align-items: center; min-height: 100vh; overflow: hidden; }
        #game-header { margin-top: 15px; }
        #game-header h1 { font-size: 2rem; margin: 0; color: #ff3e3e; text-shadow: 0 0 15px #ff3e3e; }
        #game-container { position: relative; width: 95vw; max-width: 450px; height: 70vh; max-height: 600px; background: #000; border: 3px solid #444; border-radius: 15px; margin-top: 10px; overflow: hidden; }
        canvas { width: 100%; height: 100%; display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 15px; box-sizing: border-box; }
        .stats-row { display: flex; justify-content: space-between; font-size: 1.1rem; font-weight: bold; margin-bottom: 5px; }
        #damage-flash { position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(255,0,0,0); pointer-events: none; transition: background 0.1s; }
        .boss-warning { position: absolute; top: 35%; width: 100%; text-align: center; color: #ff0000; font-size: 2.2rem; font-weight: bold; display: none; animation: blink 0.5s infinite; }
        @keyframes blink { 0%, 100% { opacity: 0; } 50% { opacity: 1; } }
        #menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: auto; text-align: center; background: rgba(0,0,0,0.9); padding: 30px; border-radius: 20px; width: 85%; border: 2px solid #ff3e3e; z-index: 10; }
        button { background: #ff3e3e; border: none; padding: 12px 25px; font-size: 1.1rem; font-weight: bold; color: white; border-radius: 50px; cursor: pointer; margin: 10px; }
        .bottom-controls { width: 95vw; max-width: 450px; display: flex; justify-content: center; gap: 20px; padding: 15px 0; background: #050507; }
        .ctrl-btn { background: #222; font-size: 0.9rem; padding: 10px 20px; color: #ccc; border-radius: 10px; border: 1px solid #444; pointer-events: auto; cursor: pointer; }
    </style>
</head>
<body>

    <div id="game-header"><h1>BOSS RAID</h1></div>

    <div id="game-container">
        <div id="damage-flash"></div>
        <canvas id="gameCanvas"></canvas>
        <div id="ui-layer">
            <div class="stats-row">
                <span>HI-SCORE: <span id="hiScore" style="color:#ff0">0</span></span>
                <span id="lifeDisplay" style="color:#f44; letter-spacing: 2px;">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
            </div>
            <div class="stats-row">
                <span>SCORE: <span id="score" style="color:#0cf">0</span></span>
                <span>TIME: <span id="time" style="color:#ff0">0</span>s</span>
            </div>
            <div id="bossWarning" class="boss-warning">WARNING: BOSS EVOLVING!</div>
            <div id="menu">
                <h2 id="menuTitle" style="color:#ff3e3e;">READY?</h2>
                <div id="scoreBoard" style="margin-bottom: 15px; line-height: 1.6;">
                    <p id="menuScoreText"></p>
                    <p id="bestScoreText" style="color:#ff0; font-weight: bold;"></p>
                </div>
                <button id="startBtn" onclick="startGame()">Ï†ÑÌà¨ ÏãúÏûë</button>
            </div>
        </div>
    </div>

    <div class="bottom-controls">
        <button class="ctrl-btn" id="soundBtn" onclick="toggleSound()">üîä Sound ON</button>
        <button class="ctrl-btn" onclick="togglePause()">|| ÏùºÏãúÏ†ïÏßÄ</button>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const hiScoreDisplay = document.getElementById('hiScore');
const timeDisplay = document.getElementById('time');
const lifeDisplay = document.getElementById('lifeDisplay');
const menu = document.getElementById('menu');
const menuTitle = document.getElementById('menuTitle');
const bossWarning = document.getElementById('bossWarning');
const flash = document.getElementById('damage-flash');

canvas.width = 450;
canvas.height = 650;

const soldierImg = new Image(); soldierImg.src = 'soldier.png';
const badImg = new Image(); badImg.src = 'bad.png';
const bossImg = new Image(); bossImg.src = 'boss.png';

let player = { x: 225, y: 580, size: 35, weaponLv: 1, bulletSize: 6, lives: 5, invul: 0 };
let bullets = [], enemyBullets = [], enemies = [], items = [], bosses = [];
let isPaused = true, isSoundOn = true;
let startTime = 0, elapsedTime = 0, frameCount = 0;
let score = 0, hiScore = localStorage.getItem('bossRaidHiScore') || 0;
let bossKillCount = 0;
let isBossSummoned = false;

const BOSS_TRIGGER_SCORE = 1000; 
hiScoreDisplay.innerText = hiScore;

const weaponData = {
    1: { damage: 1, color: '#FFFFFF', speed: 10, fireRate: 15 },
    2: { damage: 2, color: '#CCFF00', speed: 12, fireRate: 12 },
    3: { damage: 5, color: '#00FFFF', speed: 15, fireRate: 10 },
    4: { damage: 10, color: '#4400FF', speed: 17, fireRate: 8 },
    5: { damage: 18, color: '#FFFF00', speed: 19, fireRate: 7 },
    6: { damage: 30, color: '#F0F0F0', speed: 22, fireRate: 5 }
};

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(f, t, d, v) {
    if (!isSoundOn) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = t; o.frequency.setValueAtTime(f, audioCtx.currentTime);
    g.gain.setValueAtTime(v, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + d);
}

function toggleSound() {
    isSoundOn = !isSoundOn;
    document.getElementById('soundBtn').innerText = isSoundOn ? "üîä Sound ON" : "üîá Sound OFF";
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

const handleInput = (e) => {
    if (isPaused) return;
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const scaleX = canvas.width / rect.width;
    player.x = Math.max(player.size, Math.min(canvas.width - player.size, (clientX - rect.left) * scaleX));
};
window.addEventListener('mousemove', handleInput);
window.addEventListener('touchmove', (e) => { e.preventDefault(); handleInput(e); }, { passive: false });

function startGame() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    isPaused = false; menu.style.display = 'none';
    if(player.lives <= 0 || elapsedTime === 0) resetGame();
    requestAnimationFrame(loop);
}

function togglePause() {
    isPaused = !isPaused;
    menu.style.display = isPaused ? 'block' : 'none';
    if (isPaused) menuTitle.innerText = "ÏùºÏãúÏ†ïÏßÄ";
    else requestAnimationFrame(loop);
}

function resetGame() {
    player = { x: 225, y: 580, size: 35, weaponLv: 1, bulletSize: 6, lives: 5, invul: 0 };
    bullets = []; enemyBullets = []; enemies = []; items = []; bosses = [];
    score = 0; bossKillCount = 0; isBossSummoned = false;
    elapsedTime = 0; frameCount = 0; startTime = Date.now();
    updateUI();
}

function playerHit() {
    if (player.invul > 0) return;
    player.lives--;
    player.invul = 90; 
    triggerFlash();
    playSound(100, 'sine', 0.5, 0.2);
    if (player.lives <= 0) gameOver();
}

function triggerFlash() {
    flash.style.background = "rgba(255, 0, 0, 0.4)";
    setTimeout(() => flash.style.background = "rgba(255, 0, 0, 0)", 100);
}

function updateUI() {
    scoreDisplay.innerText = score;
    timeDisplay.innerText = elapsedTime;
    lifeDisplay.innerText = "‚ù§Ô∏è".repeat(Math.max(0, player.lives));
    if (score > hiScore) {
        hiScore = score;
        hiScoreDisplay.innerText = hiScore;
        localStorage.setItem('bossRaidHiScore', hiScore);
    }
}

function update() {
    if (isPaused) return;
    frameCount++;
    if (player.invul > 0) player.invul--;
    elapsedTime = Math.floor((Date.now() - startTime) / 1000);
    updateUI();

    const isBossActive = bosses.length > 0;
    const spawnRate = isBossActive ? 60 : Math.max(10, 45 - Math.floor(elapsedTime / 10)); 
    
    if (frameCount % spawnRate === 0) {
        enemies.push({ 
            x: Math.random() * (canvas.width - 40) + 20, y: -40, 
            hp: 2 + Math.floor(elapsedTime / 20),
            size: 20 + Math.random() * 10, speed: 2 + (elapsedTime / 65),
            lastShot: frameCount
        });
    }

    if (!isBossActive && score >= (bossKillCount + 1) * BOSS_TRIGGER_SCORE && !isBossSummoned) {
        isBossSummoned = true;
        bossWarning.style.display = 'block';
        playSound(60, 'square', 2.5, 0.25);
        setTimeout(() => {
            bossWarning.style.display = 'none';
            const evolveFactor = bossKillCount;
            bosses.push({
                x: canvas.width / 2, y: -150, 
                size: Math.min(150, 70 + evolveFactor * 15),
                hp: 400 + (evolveFactor * 400), maxHp: 400 + (evolveFactor * 400),
                speed: 0.7 + (evolveFactor * 0.2),
                lastShot: frameCount
            });
            isBossSummoned = false;
        }, 3000);
    }

    const wp = weaponData[player.weaponLv];
    if (frameCount % wp.fireRate === 0) {
        bullets.push({ x: player.x, y: player.y - 35, ...wp, size: player.bulletSize, lv: player.weaponLv });
        playSound(700, 'sine', 0.08, 0.02);
    }

    enemies.forEach(e => {
        // [Î≥ÄÍ≤Ω] Ï†ÅÍµ∞ Ï¥ùÏïå Î∞úÏÇ¨ ÎπàÎèÑ ÏÇ¥Ïßù Í∞êÏÜå (120 -> 160ÌîÑÎ†àÏûÑ)
        if (frameCount - e.lastShot > 160) { 
            enemyBullets.push({ x: e.x, y: e.y + 10, speed: 3.5, size: 5, color: '#FF2222', vx: 0 });
            e.lastShot = frameCount;
        }
    });

    bosses.forEach(b => {
        if (frameCount % 80 === 0) { 
            for(let i=-1; i<=1; i++) {
                enemyBullets.push({ x: b.x + (i*20), y: b.y + b.size/2, speed: 4, size: 7, color: '#FF00FF', vx: i*1.2 });
            }
            playSound(150, 'square', 0.2, 0.05);
        }
    });

    bullets.forEach((b, bi) => {
        b.y -= b.speed;
        bosses.forEach((boss, bsi) => {
            if (Math.hypot(boss.x - b.x, boss.y - b.y) < boss.size) {
                boss.hp -= b.damage;
                bullets.splice(bi, 1);
                if (boss.hp <= 0) {
                    score += 5000 + (bossKillCount * 1000);
                    bossKillCount++;
                    const itemType = Math.random() > 0.7 ? 'heart' : 'power';
                    items.push({ x: boss.x, y: boss.y, type: itemType, lv: Math.min(6, player.weaponLv + 1) });
                    bosses.splice(bsi, 1);
                }
            }
        });
        enemies.forEach((e, ei) => {
            if (Math.hypot(e.x - b.x, e.y - b.y) < e.size) {
                e.hp -= b.damage;
                bullets.splice(bi, 1);
                if (e.hp <= 0) {
                    score += 100;
                    const rand = Math.random();
                    if (rand > 0.90) {
                        const itemType = rand > 0.97 ? 'heart' : 'power';
                        items.push({ x: e.x, y: e.y, type: itemType, lv: player.weaponLv + 1 });
                    }
                    enemies.splice(ei, 1);
                }
            }
        });
    });

    enemyBullets.forEach((eb, ebi) => {
        eb.y += eb.speed;
        if (eb.vx) eb.x += eb.vx;
        if (Math.hypot(player.x - eb.x, player.y - eb.y) < (player.size * 0.75) + eb.size) {
            enemyBullets.splice(ebi, 1);
            playerHit();
        }
    });

    bosses.forEach(b => {
        if (b.y < 150) b.y += 1.5;
        else b.x += Math.sin(frameCount / 40) * (b.speed * 5);
    });

    enemies.forEach((e, ei) => {
        e.y += e.speed;
        if (Math.hypot(player.x - e.x, player.y - e.y) < (player.size * 0.8) + e.size) {
            enemies.splice(ei, 1); playerHit();
        }
        if (e.y > canvas.height + e.size) {
            enemies.splice(ei, 1); playerHit();
        }
    });

    items.forEach((item, ii) => {
        item.y += 2.2;
        if (Math.hypot(player.x - item.x, player.y - item.y) < player.size + 15) {
            if (item.type === 'heart') {
                player.lives++;
                playSound(500, 'sine', 0.3, 0.1);
            } else {
                player.weaponLv = Math.min(6, item.lv);
                player.bulletSize = Math.min(100, player.bulletSize * 1.2); 
                playSound(900, 'sine', 0.2, 0.1);
            }
            items.splice(ii, 1);
        }
    });

    bullets = bullets.filter(b => b.y > -50);
    enemyBullets = enemyBullets.filter(eb => eb.y < canvas.height + 50);
}

function gameOver() {
    isPaused = true; menu.style.display = 'block';
    menuTitle.innerText = "GAME OVER";
    document.getElementById('menuScoreText').innerText = `ÏµúÏ¢Ö Ï†êÏàò: ${score}`;
    document.getElementById('bestScoreText').innerText = `ÏµúÍ≥† Í∏∞Î°ù: ${hiScore}`;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    bosses.forEach(b => {
        if (bossImg.complete) ctx.drawImage(bossImg, b.x - b.size, b.y - b.size, b.size * 2, b.size * 2);
        ctx.fillStyle = '#222'; ctx.fillRect(b.x - 60, b.y - b.size - 25, 120, 8);
        ctx.fillStyle = '#f00'; ctx.fillRect(b.x - 60, b.y - b.size - 25, (b.hp/b.maxHp) * 120, 8);
    });
    if (!(player.invul > 0 && frameCount % 6 < 3)) {
        if (soldierImg.complete) {
            const drawSize = player.size * 2.5; 
            ctx.drawImage(soldierImg, player.x - drawSize/2, player.y - drawSize/2, drawSize, drawSize);
        }
    }
    enemies.forEach(e => {
        if (badImg.complete) ctx.drawImage(badImg, e.x - e.size, e.y - e.size, e.size * 2, e.size * 2);
    });
    
    bullets.forEach(b => {
        ctx.save();
        ctx.shadowBlur = b.lv * 6;
        ctx.shadowColor = b.color;
        if(b.lv === 6) { ctx.shadowBlur = 25; ctx.shadowColor = '#FFD700'; }
        ctx.fillStyle = b.color;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });

    enemyBullets.forEach(eb => {
        ctx.shadowBlur = 8; ctx.shadowColor = eb.color;
        ctx.fillStyle = eb.color; ctx.beginPath(); ctx.arc(eb.x, eb.y, eb.size, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
    });

    items.forEach(item => {
        ctx.save();
        if (item.type === 'heart') {
            ctx.shadowBlur = 15; ctx.shadowColor = '#ff4444';
            ctx.fillStyle = '#ff4444';
            ctx.beginPath(); ctx.arc(item.x, item.y, 20, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("H", item.x, item.y);
        } else {
            ctx.shadowBlur = 15; ctx.shadowColor = '#ff0';
            ctx.fillStyle = '#ff0';
            ctx.beginPath(); ctx.arc(item.x, item.y, 20, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("P", item.x, item.y);
        }
        ctx.restore();
    });
}
function loop() { if (!isPaused) { update(); draw(); requestAnimationFrame(loop); } }
</script>
</body>
</html>